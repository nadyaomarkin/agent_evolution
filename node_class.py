# node class will define the vertex class, except the 
# seeds now represent rules from update_chi method. 



import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation


import weakref
import sympy as sympy
import string 
import random
import string
import random as nonpseudo_random
import copy as copy
import copy
import update_chi   # this is the update_chi function from update_chi.py
from update_chi import *

# last edited dec14, 2023

from base import convert_to_base_as_list
# from map3 import general_state_transition, state_input_to_number, map_general
from map5 import general_state_transition

# write a method for a state transition, given an input

image_list = []
mm=1  # output state-space = 2^mm
nn=3  # total-input state-space = 2^nn 



# output_alphabet=['a','b','c'] #not ok
# output_alphabet=['a','b'] # ok
# output_alphabet=['a','b','c','d'] #not ok
# input_alphabet = output_alphabet
binary_alphabet = ['0','1']

import set_parameters as params
homo = params.homo
input_alphabet = params.input_alphabet
output_alphabet = params.output_alphabet

state_alphabet = params.state_alphabet  
action_alphabet = params.action_alphabet
connectivity_parameter = params.connectivity_parameter


network_size = params.network_size
network_upper_limit = params.network_upper_limit
action_dict = params.action_dict






# next define a function that updates the output based on the current state and the input
def output_transition(state, input = None, seed = 1, 
                      output_alphabet = output_alphabet, 
                      input_alphabet = max(input_alphabet, state_alphabet)):

    data_arithmetic_rule = seed_to_data_arithmetic_rule(seed)
    output = update_chi(input = input, data_arithmetic_rule = data_arithmetic_rule, 
                        alphabet = input_alphabet)

    return output

# test output transition function




# todo from pulling data, to pushing data (to avoid void pulls in the absence of updates)


import set_parameters as params
class Vertex:
    def __init__(self, state_value='', output_value = None, 
                 input = '', 
                 tag_value = '',
                 vertex_action = '',

# each seed is now a data_arithmetic rule 
                vertex_state_seed = '',            
                vertex_output_seed = '',           # input -> output # ratrat
                vertex_action_seed = '',           # input -> action ?
                vertex_tag_seed = '',              # tag -> tag'
                vertex_rule_seed = '',              # rule -> rule'

                 vertex_state_alphabet = state_alphabet, # needed for data_arithmetic_rule
                 vertex_input_alphabet = input_alphabet, 
                 vertex_output_alphabet = output_alphabet, 
                 vertex_action_alphabet = action_alphabet, 
                 vertex_rule_alphabet = data_arithmetic_alphabet, 

                 father_network = None,
                 
                 # skew parameters
                capacity_skew = params.capacity_skew,
                do_nothing_skew = params.do_nothing_skew,
                action_int = params.action_choice,
                do_this_action = params.do_this_action,
                action_choice = params.action_choice
                ):
        

        # the seeds are now data_arithmetic rules, generated by ['l', 'r', 't', 'a', 'd', 'i', 't', 'p', 'c']
        # these are transition functios for the state, output, action, and address-tag of the vertex.


        # currently transition functions are defined for stateless scenario:
        # transition input: data_arithmetic_rule_output: input -> output
        self.vertex_state_seed = vertex_state_seed
        self.vertex_output_seed = vertex_output_seed
        self.vertex_action_seed = vertex_action_seed
        self.vertex_tag_seed = vertex_tag_seed
        self.vertex_rule_seed = vertex_rule_seed,

        # print('relevant attributes are now: self.vertex_state_seed', self.vertex_state_seed, 'self.vertex_output_seed', self.vertex_output_seed, 'self.vertex_action_seed', self.vertex_action_seed)

        ######### rule-based-arithmetic attributes

        # self.data_arithmetic_rule_state = seed_to_data_arithmetic_rule(vertex_state_seed)
        # self.data_arithmetic_rule_output = seed_to_data_arithmetic_rule(vertex_output_seed)
        # self.data_arithmetic_rule_action = seed_to_data_arithmetic_rule(vertex_action_seed)
        # self.data_arithmetic_rule_tag = seed_to_data_arithmetic_rule(vertex_state_seed)

        self.data_arithmetic_rule_tag = vertex_state_seed  # tag*
        self.data_arithmetic_rule_output = vertex_output_seed # val*
        self.data_arithmetic_rule_rule = vertex_rule_seed  # tag** 

        self.data_arithmetic_rule_state = vertex_state_seed
        self.data_arithmetic_rule_action = vertex_action_seed

        self.single_rule = ''




        self.life = 0
        father_network = father_network
 
        self.state = state_value
        self.state_receive_mode = True
        self.action = vertex_action
        self.output_value = output_value
        self.input = ''

        self.vertex_state_alphabet = vertex_state_alphabet
        self.vertex_action_alphabet = vertex_action_alphabet
        self.vertex_output_alphabet = vertex_output_alphabet
        self.vertex_rule_alphabet = vertex_rule_alphabet


        
        self.temp_output = None

                # queue related attributes
        self.tag_value = tag_value  # this is the address-tag of the vertex 
        self.ready = True


        #  
        



        self.vertex_input_alphabet = vertex_input_alphabet
        self.vertex_output_alphabet = vertex_output_alphabet
        self.vertex_action_alphabet = vertex_action_alphabet

        # self skew-parameters
        self.capacity_skew = capacity_skew
        self.do_nothing_skew = do_nothing_skew
        # self.action_int = action_int
        self.do_this_action = do_this_action # this is a probability
        self.action_choice = action_choice  # this is an integer, corresponding to the action in the action_dict, e.g.
        # action_dict = {'add_vertex': 0, 'delete_vertex': 1, 'update_seed': 2, 'add_edge': 3, 'delete_edge': 4, 'do_nothing': 5, 'move_edge': 6}
        # self.action_choice = action_dict['update_seed'] # 





    
    # redefine the update_seed method to update the seed via a data_arithmetic rule
    # keeping the atavistic rs arguments for the sake of code coherence. they are in fact irrelevant. 
    # updating all the node's rules using the data_arithmetic_rule argument
    def update_seed(self, homogeneous = True, 
                    data_arithmetic_rule ='', 
                    alphabet = data_arithmetic_alphabet):
        

        self.data_arithmetic_rule_action = update_chi(input = self.data_arithmetic_rule_action, 
                                                      data_arithmetic_rule=data_arithmetic_rule, 
                                                      alphabet=alphabet)
        # alphabet is passed down to be data_arithmetic_alphabet = ['l', 'r', 't', 'a', 'd', 'i', 't', 'p', 'c']

        self.data_arithmetic_rule_output = update_chi(input = self.data_arithmetic_rule_output, 
                                                      data_arithmetic_rule=data_arithmetic_rule,
                                                        alphabet=alphabet)
        self.data_arithmetic_rule_state = update_chi(input = self.data_arithmetic_rule_state, data_arithmetic_rule=data_arithmetic_rule,
                                                        alphabet=alphabet)
         
        self.data_arithmetic_rule_tag = update_chi(input = self.data_arithmetic_rule_tag, 
                                                   data_arithmetic_rule=data_arithmetic_rule,
                                                        alphabet=alphabet)

        # update all the seeds to match up with data_arithmetic_rule, just in case.

        #Â just in case, to be consistent. 
        self.vertex_action_seed = self.data_arithmetic_rule_action
        self.vertex_output_seed = self.data_arithmetic_rule_output
        self.vertex_state_seed = self.data_arithmetic_rule_state
        self.vertex_tag_seed = self.data_arithmetic_rule_tag

        
            



    # apply arg or own data_arithmetic_rule_tag to the tag, to produce a new tag
    def make_destination_tag(self, tag_value = '', data_arithmetic_rule=None):
        if tag_value == '':
            tag_value = self.tag_value
        # use current tag to produce a new destination tag
        if data_arithmetic_rule == None:
            data_arithmetic_rule = self.data_arithmetic_rule_tag # tag*
        destination_tag = update_chi(input = tag_value, 
                                     data_arithmetic_rule = data_arithmetic_rule, 
                                     alphabet = self.vertex_input_alphabet)
        return destination_tag
        

    def update_action(self):

        # will define new action based up update_chi method.
        new_action = update_chi(input = self.action, 
                                data_arithmetic_rule = self.data_arithmetic_rule_action, 
                                alphabet = self.vertex_action_alphabet)
        # take the first letter
        if new_action != '':
            new_action = new_action[0]

        self.action = new_action
        # now we additionally skew the action, which is done in a separate method
        do_nothing_skew = params.do_nothing_skew
        capacity_skew = params.capacity_skew
        return self.skew_action()



######### skew action method 


# skewing changes the existing action to a new action, based on the skew parameters.
    # the skew hierarcy is as follows: current action < do_this_action <  do_nothing_skew < capacity_skew
    # when do_this_action is 0, the action is always the same.
    def skew_action(self):
        capacity_skew = params.capacity_skew
        do_nothing_skew = params.do_nothing_skew
        action_int = params.action_choice
        do_this_action = params.do_this_action

    # now we implement these skew-parameters as class attributes, inherited by vertex from the network.

        capacity_skew = self.capacity_skew
        do_nothing_skew = self.do_nothing_skew
        action_int = self.action_choice  # 
        do_this_action = self.do_this_action

    


        # priority do_this_action < do_nothing_skew < capacity_skew



        new_action = self.action
        # do_this_action skew
        xr = random.random()
        if xr < do_this_action:
            new_action = str(action_int)

        xr = random.random()
        if xr < do_nothing_skew:
            new_action = str(action_dict['do_nothing'])

        # finish with capacity skew to control size. 
        if capacity_skew:
            capacity = network_size/network_upper_limit
            capacity = capacity*1  # this is tag delete-skew behaviour.
            # when network reaches capacity, we want to skew it toward vertex-deletion.
            xr = random.random()
            if xr < capacity: # this is likely as capcity approaches 1, maximum.
                new_action = str(action_dict['delete_vertex'])
        

        self.action = new_action
        return new_action


    
    # next we incorporate this action into the update_node method.



    # input-output map
    def update_output(self, mode = 'arithmetic'):

        # if self.input == '': #ratrat
        #     self.input = '00001'
        if mode == 'arithmetic':
            # apply rule to input to produce output
            output = update_chi(input = self.input, 
                                data_arithmetic_rule = self.data_arithmetic_rule_output, 
                                alphabet = self.vertex_input_alphabet)
            print('applied rule:', self.data_arithmetic_rule_output, 'to input:', self.input, 'got output:', output)
            self.output_value = output
            return output
        if mode == 'logic':
            output = update_chi(input = self.input, 
                                data_arithmetic_rule = self.data_arithmetic_rule_output, 
                                alphabet = self.vertex_input_alphabet,
                                mode = 'logic')
            self.output_value = output
            return output
    

    # updating node's mutable attributes: state, action, tag, rules
    def update_node(self, useinput = True):  
        self.update_state()
        self.update_action()


        if useinput:
            self.update_rule(useinput = True)
            return
        # if not using input, then update each rule separately, using the rule itself
        self.update_rule(rule_to_update = 'tag', useinput = False) # checkcheck this was originally not included. because the tag is already updated by the rule itself. 



        self.update_rule(rule_to_update = 'output', useinput = False)
        self.update_rule(rule_to_update = 'rule', useinput = False)

        
        self.update_rule(rule_to_update = 'state', useinput = False)
        self.update_rule(rule_to_update = 'action', useinput = False)
        return 

    # method for updating node's tags. unless these are enviornment nodes, which have tags set to '11111' or '00000'
    def update_tag(self):
        # these are reserved for environment 
        if self.tag_value == '11111' or self.tag_value == '00000':
            return self.tag_value
        
        # update the tag using the tag rule
        self.tag_value = update_chi(input = self.tag_value, 
                                    data_arithmetic_rule = self.data_arithmetic_rule_tag, 
                                    alphabet = self.vertex_input_alphabet)
        return self.tag_value

    def update_state(self, trancation = 100):
        # updating state using rule = self.data_arithmetic_rule_state       
        state = update_chi(input = self.state, 
                                data_arithmetic_rule = self.data_arithmetic_rule_state, 
                                alphabet = self.vertex_state_alphabet)
        # truncate it to 100 characters
        self.state = state[:trancation]
        return self.state 
        

    # applies its rule to itself
        

    # update_rule applies a rule to the node's mulitple 'rule'-attributes. 
    # the useinput option allows the rule to be generated from the input, which is stored as a nodes (temporary) attribute.
    # if rule-to-apply arg is None, and the useiinput is set to False, then node uses its own rule to update itself. 
        # this is done similarly for state-rule, output-rule, and action-rule.
    def update_rule(self, rule_to_apply = None, rule_to_update = None, useinput = False):
        vertex = self

        # todo: instead ^^ separate into arg for rule and arg for output. or transition func on input for input_rule generation. 
        # update nodes' rule using the input_rule

        if useinput:
            # convert node's input into a rule that can act on the nodes current rule

            # use the binary to rule method to read input in blocks of 4 bits, and convert to rule
            input_rule = self.binary_to_rule(self.input) # can potentially reach all rule-letters

            # input transforming each node tag and node-rule 
            # [rule-tag, rule-rules]
            # [rule-tag, [rule-tag, rule-rule]]
            vertex.update_rule(rule_to_apply = input_rule, rule_to_update = 'tag', useinput = False)
            vertex.update_rule(rule_to_apply = input_rule, rule_to_update = 'rule', useinput = False)

            vertex.update_rule(rule_to_apply = input_rule, rule_to_update = 'state', useinput = False)
            vertex.update_rule(rule_to_apply = input_rule, rule_to_update = 'output', useinput = False)
            vertex.update_rule(rule_to_apply = input_rule, rule_to_update = 'action', useinput = False)


            return 


        # we create a list of rule-attributes, that we will set, depending on the 'rule_to_update' argument
        # so if rule_to_update is 'rule', we will update self.data_arithmetic_rule_rule using rule_to_apply
        rule_attribute_dict = {'rule': 'data_arithmetic_rule_rule', 
                               'output': 'data_arithmetic_rule_output', 
                
                               'tag': 'data_arithmetic_rule_tag',
                               'state': 'data_arithmetic_rule_state', 
                               'action': 'data_arithmetic_rule_action'}
                

        if rule_to_update == None: # rule_to_update tells us which rule to update: rule for state, output, action, or tag, or rule
            return



        cases = False
        # cases = True

        if not cases:    
            attribute_to_update = rule_attribute_dict[rule_to_update]

            # now we rewrite the if-cases below using the rule_dict. 
            rule_to_update_arg = getattr(vertex, attribute_to_update)
            if rule_to_apply == None:
            # then we will use the node's own rule, coming from the corresponding attribute
                # apply rule to itself
                rule_to_apply = rule_to_update_arg
 
            # set the attribute corresponding to rule_to_update to the result of update_chi
            setattr(vertex, attribute_to_update, update_chi(input = rule_to_update_arg,
                                                    data_arithmetic_rule = rule_to_apply, 
                                                    alphabet = vertex.vertex_rule_alphabet))
 
        # for readibility just do cases. 

        if cases:   
            if rule_to_update == 'rule':
                if rule_to_apply == None:
                    rule_to_apply = self.data_arithmetic_rule_rule
                # update node's rule using rule = self.data_arithmetic_rule_rule
                    
                self.data_arithmetic_rule_rule = update_chi(input = self.data_arithmetic_rule_rule, 
                                                            data_arithmetic_rule = rule_to_apply, 
                                                            alphabet = self.vertex_rule_alphabet)
                # for consistency also set the rule-seed
                self.vertex_rule_seed = self.data_arithmetic_rule_rule

            if rule_to_update == 'state':
                if rule_to_apply == None:
                    rule_to_apply = self.data_arithmetic_rule_state
                # update node's rule using rule = self.data_arithmetic_rule_rule
                    
                self.data_arithmetic_rule_state = update_chi(input = self.data_arithmetic_rule_state, 
                                                            data_arithmetic_rule = rule_to_apply, 
                                                            alphabet = self.vertex_rule_alphabet)
                # for consistency also set the rule-seed
                self.vertex_state_seed = self.data_arithmetic_rule_state

            if rule_to_update == 'output':
                if rule_to_apply == None:
                    rule_to_apply = self.data_arithmetic_rule_output
                # update node's rule using rule = self.data_arithmetic_rule_rule
                    
                self.data_arithmetic_rule_output = update_chi(input = self.data_arithmetic_rule_output, 
                                                            data_arithmetic_rule = rule_to_apply, 
                                                            alphabet = self.vertex_rule_alphabet)
                # for consistency also set the rule-seed
                self.vertex_output_seed = self.data_arithmetic_rule_output
            if rule_to_update == 'action':
                if rule_to_apply == None:
                    rule_to_apply = self.data_arithmetic_rule_action
                # update node's rule using rule = self.data_arithmetic_rule_rule
                    
                self.data_arithmetic_rule_action = update_chi(input = self.data_arithmetic_rule_action, 
                                                            data_arithmetic_rule = rule_to_apply, 
                                                            alphabet = self.vertex_rule_alphabet)
                # for consistency also set the rule-seed
                self.vertex_action_seed = self.data_arithmetic_rule_action

    # now instead of updating state, input-output, rules, and tag separately we write one method that updates all of them.
    # first we need to ensure that everything comes from one alphabet, it will be binary. so there will be a rule-encoding, that 
    # that will take the rule generators ['l', 'r', 't', 'a', 'd', 'i', 't', 'p', 'c'] and encode them into binary, as 4-bit numbers.
    
    # def hashtable for the rule-encoding
    def rule_to_binary(self, rule = ''):
        rule_dict = {'l': '0000', 'r': '0001', 't': '0010', 'a': '0011', 'd': '0100', 'i': '0101', 't': '0110', 'p': '0111', 'c': '1000'}
        binary_rule = ''
        for s in rule:
            binary_rule += rule_dict[s]
        return binary_rule
    def binary_to_rule(self, binary_rule = ''):
        rule_dict = {'0000': 'l', '0001': 'r', '0010': 't', '0011': 'a', '0100': 'd', '0101': 'i', '0110': 't', '0111': 'p', '1000': 'c'}
        rule = ''
        for i in range(0, len(binary_rule), 4):
            # make sure the length is ok
            if i+4 > len(binary_rule):
                break
            rulestep = binary_rule[i:i+4]
            if rulestep in rule_dict:
                rule += rule_dict[rulestep]
        return rule
    # ok. now we are ready to update the node as follows: 
    # we assume that all the attributes tag, input, state, action are 5-bit binary strings.
    # we create a variable-length binary string that concatenates all of them, including the rule in the last position. 
    # now the update applies the rule-part of the string to the rest of the string, and then splits the string back into its components.
    def onerule_update(self):

        onestring = self.tag_value + self.input + self.state + self.action + self.rule_to_binary(self.single_rule)
        # apply the rule to the string
        newstring = update_chi(input = onestring, data_arithmetic_rule = self.single_rule, alphabet=binary_alphabet)
        # parse the newstring to new node attributes: tag, output, state, action, rule
        self.tag_value = newstring[:5]
        self.output = newstring[5:10]
        self.state = newstring[10:15]
        self.action = newstring[15:20]
        self.single_rule = self.binary_to_rule(newstring[20:])
        return self.single_rule
    


# create a network of vertices. 
# then evaluate the network on updating vertex states and outputs, 
# based on the inputs from the neighbours.

# Network class is defined in verfexFSM_classes_itr_11dec.py

# test the one-rule update method
    
vv = Vertex()
vv.tag_value = '00001'
vv.action = '00010'
vv.state = '00011'
vv.input = '00100'
vv.single_rule = 'llaiai'

print('onestring:', vv.tag_value + ' ' + vv.input + ' ' + vv.state + ' ' + vv.action + ' ' + vv.rule_to_binary(vv.single_rule))
# print all attributes separately
print('tag:', vv.tag_value, 'input:', vv.input, 'state:', vv.state, 'action:', vv.action, 'rule:', vv.single_rule, 'rule-binary:', vv.rule_to_binary(vv.single_rule))



for ii in range(0):
    vv.single_rule = vv.onerule_update()
    #print new attributes
    vv.input = vv.output
    #print all attributes as one string, separated by ''
    print('onestring:', vv.tag_value + ' ' + vv.input + ' ' + vv.state + ' ' + vv.action + ' ' + vv.rule_to_binary(vv.single_rule))
    # print all attributes separately
    print('tag:', vv.tag_value, 'input:', vv.input, 'state:', vv.state, 'action:', vv.action, 'rule:', vv.single_rule, 'rule-binary:', vv.rule_to_binary(vv.single_rule))

    